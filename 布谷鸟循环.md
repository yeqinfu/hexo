---
title: 布谷鸟循环
date: 2018-09-26 14:00:58
tags: block chain
---

### 图论工作量证明

布谷鸟循环应该是为了抗矿机产生的一种算法，公链引用这种算法是为了取代原来的SHA256的方式算出目标哈希的工作量证明，通过图论，从一个图中找到目标子图的工作量证明去取代暴力随机数得到目标哈希的方式。

我们建议在大型伪随机图中找到某些子图的基础工作量证明，用G(N,M)表示在G集合里面选择关于N个节点的M边图。key可以随机，作为哈希函数的输入，我们根据哈希函数输出选择边。对于一个良好的哈希哈希函数，这两类随即图应该具有几乎相同的性质。

![image](http://ws1.sinaimg.cn/large/c1b251b3gy1fwb7cesajyj20ap017748.jpg)

说这是一个哈希方法体，具体是两个集合K次方再乘积，先看{0,1}的k次方代表啥

> 就是K个集合{0,1}做直积，
>
> 假设K=2，那就是{0,1}*{0,1}得到结果是
>
> {(0,0),(0,1),(1,0),(1,1)}
>
> 假设K=3那结果就是
>
> ｛（0,0,0）（0,0,1）（0,1,0）（0,1,1）（1,0,0）（1,0,1）（1,1,0）（1,1,1）｝

根据图片上式子，是否存在底数不变，指数相加减呢？也就是K+Wi=Wo

> 应该是成立的哈哈

上面的式子中乘号左边可以代表一个矩阵集合，这个矩阵长宽相等为K，乘号右边也是一个矩阵长宽相等为Wi，矩阵的元素是一个集合，集合的数量就是K或者Wi

现在在这个矩阵中找一个小的图H，也就是目标子图，选择一个最大的数N<=2(W次方)作为节点，M<=2(Wi-1次方)作为变，每个key生成图。。。看下面英文

![image](http://ws3.sinaimg.cn/large/c1b251b3gy1fwb8kx10ivj20yy042myh.jpg)













[英文参考](https://github.com/tromp/cuckoo)

假设我们有M个随机数，我们存储这些随机数是用这些随机数的生成的哈希值作为key，存入一个哈希表中的，那么以后就可以根据key来找到这些随机数。

但是我们知道在哈希表中的key有可能冲突，也就是哈希冲突。

每个key都有两个哈希位置可以有三种情况

+ 两个哈希方法对应的位置都是空的，选一个

+ 一个空，一个不空，选不空那一个

+ 两个都不空，这时候选哪个呢？所以这里维护了一个图来表明选哪个比较合算

  ​

> 因为两个都不空，根据布谷鸟规则，必须去占领一个位置，被占领的key，去根据它的另外的哈希方法去找新的位置，它也可能面临以上的三种情况，这样子递归下去



![image](http://ws4.sinaimg.cn/large/c1b251b3gy1fvpag5t32bj21540awq4z.jpg)

上面第三点所说的图，可以如上图表示，这个图维护了证明当需要翻转的时候的最佳情况

如左图所示，每一条边代表的是一个key，而根据这个key能查到哪一个节点（随机数）取决于是发射点，比如2和15代表着冲突的时候，2和15会有一个哈希方法值是一样的，但是被15占领了，也就是根据这个key只能查到15

再看4这个节点，代表着4和15冲突了但是冲突的key能查到4，但是发现4接收了两个射线，之前说每个节点有两个哈希函数，也就是能映射出两个key，这里接收两个箭头可能并不是代表它超过了两个哈希函数，而是仅仅说他们发生冲突的时候，决策的时候的一个记录。

添加一个射线10,11。先追溯最短的路径，翻转最短的路径，意味着原本11,12冲突的key是给11用的，现在改成给12用的，而10,11冲突的key转给11用。得到了图中

然后再看10,13这新增的，先判断10:10->8 再判断13:13->4>15>2所以翻转10那部分，恰好不用翻转直接由短的树指向长的数而没有冲突

#### 总结

上述的替换规则总的来说为了是避免进入一个死循环，他能保证布谷鸟哈希key移动的时候不会进入死循环，呈现出一个树形。而翻转射线方向就是树形的关键

前一篇我们用布谷鸟搜索算法，每次移动都是要判断是否移动的次数过多，然后进行表的扩张

而这里通过存图，可以保证不会过多节点出现死循环。

























































